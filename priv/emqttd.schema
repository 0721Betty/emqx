%%-*- mode: erlang -*-
%% EMQ 3.0 config mapping

%%--------------------------------------------------------------------
%% Erlang VM Args
%%--------------------------------------------------------------------

%% @doc Erlang node name
{mapping, "vm.nodename", "vm_args.-name", [
  {default, "emqttd@127.0.0.1"}
]}.

%% @doc Secret cookie for distributed erlang node
{mapping, "vm.setcookie", "vm_args.-setcookie", [
  {default, "emqsecretcookie"}
]}.

%% @doc SMP Support
{mapping, "vm.smp", "vm_args.-smp", [
  {default, auto},
  {datatype, {enum, [enable, auto, disable]}},
  hidden
]}.

%% @doc Enable Kernel Poll
{mapping, "vm.kernel_poll", "vm_args.+K", [
  {default, on},
  {datatype, flag},
  hidden
]}.

%% @doc More information at: http://erlang.org/doc/man/erl.html
{mapping, "vm.async_threads", "vm_args.+A", [
  {default, 64},
  {datatype, integer},
  {validators, ["range:0-1024"]}
]}.

%% @doc Erlang Process Limit
{mapping, "vm.process_limit", "vm_args.+P", [
  {datatype, integer},
  {default, 256000},
  hidden
]}.

%% Note: OTP R15 and earlier uses -env ERL_MAX_PORTS, R16+ uses +Q
%% @doc The number of concurrent ports/sockets
%% Valid range is 1024-134217727
{mapping, "vm.max_ports",
  cuttlefish:otp("R16", "vm_args.+Q", "vm_args.-env ERL_MAX_PORTS"), [
  {default, 262144},
  {datatype, integer},
  {validators, ["range4ports"]}
]}.

{validator, "range4ports", "must be 1024 to 134217727",
 fun(X) -> X >= 1024 andalso X =< 134217727 end}.

%% @doc http://www.erlang.org/doc/man/erl.html#%2bzdbbl
{mapping, "vm.dist_buffer_size", "vm_args.+zdbbl", [
  {datatype, bytesize},
  {commented, "32MB"},
  hidden,
  {validators, ["zdbbl_range"]}
]}.

{translation, "vm_args.+zdbbl",
 fun(Conf) ->
  ZDBBL = cuttlefish:conf_get("vm.dist_buffer_size", Conf, undefined),
  case ZDBBL of
    undefined -> undefined;
    X when is_integer(X) -> cuttlefish_util:ceiling(X / 1024); %% Bytes to Kilobytes;
    _ -> undefined
  end
 end
}.

{validator, "zdbbl_range", "must be between 1KB and 2097151KB",
 fun(ZDBBL) ->
  %% 2097151KB = 2147482624
  ZDBBL >= 1024 andalso ZDBBL =< 2147482624
 end
}.

%% @doc http://www.erlang.org/doc/man/erlang.html#system_flag-2
{mapping, "vm.fullsweep_after", "vm_args.-env ERL_FULLSWEEP_AFTER", [
  {default, 1000},
  {datatype, integer},
  hidden,
  {validators, ["positive_integer"]}
]}.

{validator, "positive_integer", "must be a positive integer",
  fun(X) -> X >= 0 end}.

%% Note: OTP R15 and earlier uses -env ERL_MAX_ETS_TABLES,
%% R16+ uses +e
%% @doc The ETS table limit
{mapping, "vm.max_ets_tables",
  cuttlefish:otp("R16", "vm_args.+e", "vm_args.-env ERL_MAX_ETS_TABLES"), [
  {default, 256000},
  {datatype, integer},
  hidden
]}.

%% @doc Set the location of crash dumps
{mapping, "vm.crash_dump", "vm_args.-env ERL_CRASH_DUMP", [
  {default, "{{crash_dump}}"},
  {datatype, file},
  hidden
]}.

%%--------------------------------------------------------------------
%% MQTT Protocol
%%--------------------------------------------------------------------

%% @doc Set the Max ClientId Length Allowed.
{mapping, "mqtt.max_clientid_len", "emqttd.mqtt_protocol", [
  {default, 1024},
  {datatype, integer}
]}.

%% @doc Max Packet Size Allowed, 64K by default.
{mapping, "mqtt.max_packet_size", "emqttd.mqtt_protocol", [
  {default, "64KB"},
  {datatype, bytesize}
]}.

%% @doc Client Idle Timeout.
{mapping, "mqtt.client_idle_timeout", "emqttd.mqtt_protocol", [
  {default, 30},
  {datatype, integer}
]}.

{translation, "emqttd.mqtt_protocol", fun(Conf) ->
  [{max_clientid_len,    cuttlefish:conf_get("mqtt.max_clientid_len", Conf)},
   {max_packet_size,     cuttlefish:conf_get("mqtt.max_packet_size", Conf)},
   {client_idle_timeout, cuttlefish:conf_get("mqtt.client_idle_timeout", Conf)}]
end}.

%%--------------------------------------------------------------------
%% MQTT Session
%%--------------------------------------------------------------------

%% @doc Max number of QoS 1 and 2 messages that can be “inflight” at one time.
%% 0 means no limit
{mapping, "mqtt.session.max_inflight", "emqttd.mqtt_session", [
  {default, 100},
  {datatype, integer}
]}.


%% @doc Retry interval for redelivering QoS1/2 messages.
{mapping, "mqtt.session.unack_retry_interval", "emqttd.mqtt_session", [
  {default, 60},
  {datatype, integer}
]}.

%% @doc Awaiting PUBREL Timeout
{mapping, "mqtt.session.await_rel_timeout", "emqttd.mqtt_session", [
  {default, 30},
  {datatype, integer}
]}.

%% @doc Max Packets that Awaiting PUBREL, 0 means no limit
{mapping, "mqtt.session.max_awaiting_rel", "emqttd.mqtt_session", [
  {default, 0},
  {datatype, integer}
]}.

%% @doc Statistics Collection Interval(seconds)
{mapping, "mqtt.session.collect_interval", "emqttd.mqtt_session", [
  {default, 0},
  {datatype, integer}
]}.

%% @doc Session expired after...
{mapping, "mqtt.session.expired_after", "emqttd.mqtt_session", [
  {default, "2d"},
  {datatype, {duration, s}}
]}.

{translation, "emqttd.mqtt_session", fun(Conf) ->
  [{max_inflight, cuttlefish:conf_get("mqtt.session.max_inflight", Conf)},
   {unack_retry_interval, cuttlefish:conf_get("mqtt.session.unack_retry_interval", Conf)},
   {await_rel_timeout, cuttlefish:conf_get("mqtt.session.await_rel_timeout", Conf)},
   {max_awaiting_rel, cuttlefish:conf_get("mqtt.session.max_awaiting_rel", Conf)},
   {collect_interval, cuttlefish:conf_get("mqtt.session.collect_interval", Conf)},
   {expired_after, cuttlefish:conf_get("mqtt.session.expired_after", Conf)}]
end}.

%%--------------------------------------------------------------------
%% MQTT Queue
%%--------------------------------------------------------------------

%% @doc Type: simple | priority
{mapping, "mqtt.queue.type", "emqttd.mqtt_queue", [
  {default, simple},
  {datatype, atom}
]}.

%% @doc Topic Priority: 0~255, Default is 0
{mapping, "mqtt.queue.priority", "emqttd.mqtt_queue", [
  {default, ""},
  {datatype, string},
  hidden
]}.

%% @doc Max queue length. Enqueued messages when persistent client disconnected, or inflight window is full.
{mapping, "mqtt.queue.max_length", "emqttd.mqtt_queue", [
  {default, infinity},
  {datatype, [atom, integer]}
]}.

%% @doc Low-water mark of queued messages
{mapping, "mqtt.queue.low_watermark", "emqttd.mqtt_queue", [
  {default, "20%"},
  {datatype, string},
  hidden
]}.

%% @doc High-water mark of queued messages
{mapping, "mqtt.queue.high_watermark", "emqttd.mqtt_queue", [
  {default, "60%"},
  {datatype, string},
  hidden
]}.

%% @doc Queue Qos0 messages?
{mapping, "mqtt.queue.qos0", "emqttd.mqtt_queue", [
  {default, true},
  {datatype, {enum, [true, false]}}
]}.

{translation, "emqttd.mqtt_queue", fun(Conf) ->
  Parse = fun(S) ->
			{match, [N]} = re:run(S, "^([0-9]+)%$", [{capture, all_but_first, list}]),
			list_to_integer(N) / 100
	      end,
  Opts = [{type, cuttlefish:conf_get("mqtt.queue.type", Conf, simple)},
          {max_length, cuttlefish:conf_get("mqtt.queue.max_length", Conf)},
          {low_watermark, Parse(cuttlefish:conf_get("mqtt.queue.low_watermark", Conf))},
          {high_watermark, Parse(cuttlefish:conf_get("mqtt.queue.high_watermark", Conf))},
          {queue_qos0, cuttlefish:conf_get("mqtt.queue.qos0", Conf)}],
  case cuttlefish:conf_get("mqtt.queue.priority", Conf) of
    undefined -> Opts;
    V -> [{priority,
			 [begin [T, P] = string:tokens(S, "="),
					{T, list_to_integer(P)}
		      end || S <- string:tokens(V, ",")]}|Opts]
  end
end}.

%%--------------------------------------------------------------------
%% MQTT Broker
%%--------------------------------------------------------------------
{mapping, "mqtt.broker.sys_interval", "emqttd.mqtt_broker", [
  {default, 60},
  {datatype, integer}
]}.

{translation, "emqttd.mqtt_broker", fun(Conf) ->
  [{sys_interval, cuttlefish:conf_get("mqtt.broker.sys_interval", Conf)}]
end}.

%%--------------------------------------------------------------------
%% MQTT PubSub
%%--------------------------------------------------------------------
{mapping, "mqtt.pubsub.pool_size", "emqttd.mqtt_pubsub", [
  {default, 8},
  {datatype, integer}
]}.

{mapping, "mqtt.pubsub.by_clientid", "emqttd.mqtt_pubsub", [
  {default, true},
  {datatype, {enum, [true, false]}}
]}.

{mapping, "mqtt.pubsub.async", "emqttd.mqtt_pubsub", [
  {default, true},
  {datatype, {enum, [true, false]}},
  hidden
]}.

{translation, "emqttd.mqtt_pubsub", fun(Conf) ->
  [{pool_size, cuttlefish:conf_get("mqtt.pubsub.pool_size", Conf)},
   {by_clientid, cuttlefish:conf_get("mqtt.pubsub.by_clientid", Conf)},
   {async, cuttlefish:conf_get("mqtt.pubsub.async", Conf)}]
end}.

%%--------------------------------------------------------------------
%% MQTT Bridge
%%--------------------------------------------------------------------
{mapping, "mqtt.bridge.max_queue_len", "emqttd.mqtt_bridge", [
  {default, 10000},
  {datatype, integer}
]}.

{mapping, "mqtt.bridge.ping_down_interval", "emqttd.mqtt_bridge", [
  {default, 1},
  {datatype, integer}
]}.

{translation, "emqttd.mqtt_bridge", fun(Conf) ->
  [{max_queue_len, cuttlefish:conf_get("mqtt.bridge.max_queue_len", Conf)},
   {ping_down_interval, cuttlefish:conf_get("mqtt.bridge.ping_down_interval", Conf)}]
end}.

%%--------------------------------------------------------------------
%% System Monitor
%%--------------------------------------------------------------------

%% @doc Long GC, don't monitor in production mode for:
%% https://github.com/erlang/otp/blob/feb45017da36be78d4c5784d758ede619fa7bfd3/erts/emulator/beam/erl_gc.c#L421
{mapping, "sysmon.long_gc", "emqttd.sysmon", [
  {default, false},
  {datatype, {enum, [true, false]}}
]}.

%% @doc Long Schedule(ms)
{mapping, "sysmon.long_schedule", "emqttd.sysmon", [
  {default, 1000},
  {datatype, integer}
]}.

%% @doc Large Heap
{mapping, "sysmon.large_heap", "emqttd.sysmon", [
  {default, "8MB"},
  {datatype, bytesize}
]}.

%% @doc Monitor Busy Port
{mapping, "sysmon.busy_port", "emqttd.sysmon", [
  {default, false},
  {datatype, {enum, [true, false]}}
]}.

%% @doc Monitor Busy Dist Port
{mapping, "sysmon.busy_dist_port", "emqttd.sysmon", [
  {default, true},
  {datatype, {enum, [true, false]}}
]}.

{translation, "emqttd.sysmon", fun(Conf) ->
    [{long_gc, cuttlefish:conf_get("sysmon.long_gc", Conf)},
     {long_schedule, cuttlefish:conf_get("sysmon.long_schedule", Conf)},
     {large_heap, cuttlefish:conf_get("sysmon.large_heap", Conf)},
     {busy_port, cuttlefish:conf_get("sysmon.busy_port", Conf)},
     {busy_dist_port, cuttlefish:conf_get("sysmon.busy_dist_port", Conf)}]
end}.

%% @doc Where to emit the default log messages (typically at 'info'
%% severity):
%%     off: disabled
%%    file: the file specified by log.console.file
%% console: to standard output (seen when using `riak attach-direct`)
%%    both: log.console.file and standard out.
{mapping, "log.console", "lager.handlers", [
  {default, file },
  {datatype, {enum, [off, file, console, both]}}
]}.

%% @doc The severity level of the console log, default is 'info'.
{mapping, "log.console.level", "lager.handlers", [
  {default, info},
  {datatype, {enum, [debug, info, notice, warning, error, critical, alert, emergency, none]}}
]}.

%% @doc When 'log.console' is set to 'file' or 'both', the file where
%% console messages will be logged.
{mapping, "log.console.file", "lager.handlers", [
  {default, "$(platform_log_dir)/console.log"},
  {datatype, file}
]}.

%% @doc The file where error messages will be logged.
{mapping, "log.error.file", "lager.handlers", [
  {default, "$(platform_log_dir)/error.log"},
  {datatype, file}
]}.

%% @doc When set to 'on', enables log output to syslog.
{mapping, "log.syslog", "lager.handlers", [
  {default, off},
  {datatype, flag}
]}.

%% @doc When set to 'on', enables log output to syslog.
{mapping, "log.syslog.ident", "lager.handlers", [
  {default, "riak"},
  hidden
]}.

%% @doc Syslog facility to log entries from Riak.
{mapping, "log.syslog.facility", "lager.handlers", [
  {default, daemon},
  {datatype, {enum,[kern, user, mail, daemon, auth, syslog,
                    lpr, news, uucp, clock, authpriv, ftp,
                    cron, local0, local1, local2, local3,
                    local4, local5, local6, local7]}},
  hidden
]}.

%% @doc The severity level at which to log entries to syslog, default is 'info'.
{mapping, "log.syslog.level", "lager.handlers", [
  {default, info},
  {datatype, {enum, [debug, info, notice, warning, error, critical, alert, emergency, none]}},
  hidden
]}.

{translation,
 "lager.handlers",
 fun(Conf) ->
    SyslogHandler = case cuttlefish:conf_get("log.syslog", Conf) of
      true ->
        Ident = cuttlefish:conf_get("log.syslog.ident", Conf),
        Facility = cuttlefish:conf_get("log.syslog.facility", Conf),
        LogLevel = cuttlefish:conf_get("log.syslog.level", Conf),
        [{lager_syslog_backend, [Ident, Facility, LogLevel]}];
      _ -> []
    end,
    ErrorHandler = case cuttlefish:conf_get("log.error.file", Conf) of
      undefined -> [];
      ErrorFilename -> [{lager_file_backend, [{file, ErrorFilename},
                                              {level, error},
                                              {size, 10485760},
                                              {date, "$D0"},
                                              {count, 5}]}]
    end,

    ConsoleLogLevel = cuttlefish:conf_get("log.console.level", Conf),
    ConsoleLogFile = cuttlefish:conf_get("log.console.file", Conf),

    ConsoleHandler = {lager_console_backend, ConsoleLogLevel},
    ConsoleFileHandler = {lager_file_backend, [{file, ConsoleLogFile},
                                               {level, ConsoleLogLevel},
                                               {size, 10485760},
                                               {date, "$D0"},
                                               {count, 5}]},

    ConsoleHandlers = case cuttlefish:conf_get("log.console", Conf) of
      off -> [];
      file -> [ConsoleFileHandler];
      console -> [ConsoleHandler];
      both -> [ConsoleHandler, ConsoleFileHandler];
      _ -> []
    end,
    SyslogHandler ++ ConsoleHandlers ++ ErrorHandler
  end
}.


%% @doc Whether to enable Erlang's built-in error logger.
{mapping, "sasl", "sasl.sasl_error_logger", [
  {default, off},
  {datatype, flag},
  hidden
]}.

%% @doc Whether to enable the crash log.
{mapping, "log.crash", "lager.crash_log", [
  {default, on},
  {datatype, flag}
]}.

%% @doc If the crash log is enabled, the file where its messages will
%% be written.
{mapping, "log.crash.file", "lager.crash_log", [
  {default, "$(platform_log_dir)/crash.log"},
  {datatype, file}
]}.

{translation,
 "lager.crash_log",
 fun(Conf) ->
     case cuttlefish:conf_get("log.crash", Conf) of
         false -> undefined;
         _ ->
             cuttlefish:conf_get("log.crash.file", Conf, "./log/crash.log")
     end
 end}.

%% @doc Maximum size in bytes of individual messages in the crash log
{mapping, "log.crash.maximum_message_size", "lager.crash_log_msg_size", [
  {default, "64KB"},
  {datatype, bytesize}
]}.

%% @doc Maximum size of the crash log in bytes, before it is rotated
{mapping, "log.crash.size", "lager.crash_log_size", [
  {default, "10MB"},
  {datatype, bytesize}
]}.

%% @doc The schedule on which to rotate the crash log.  For more
%% information see:
%% https://github.com/basho/lager/blob/master/README.md#internal-log-rotation
{mapping, "log.crash.rotation", "lager.crash_log_date", [
  {default, "$D0"}
]}.

%% @doc The number of rotated crash logs to keep. When set to
%% 'current', only the current open log file is kept.
{mapping, "log.crash.rotation.keep", "lager.crash_log_count", [
  {default, 5},
  {datatype, [integer, {atom, current}]},
  {validators, ["rotation_count"]}
]}.

{validator,
 "rotation_count",
 "must be 'current' or a positive integer",
 fun(current) -> true;
    (Int) when is_integer(Int) andalso Int >= 0 -> true;
    (_) -> false
 end}.

{translation,
 "lager.crash_log_count",
 fun(Conf) ->
    case cuttlefish:conf_get("log.crash.rotation.keep", Conf) of
       current -> 0;
       Int -> Int
    end
 end}.

%% @doc Whether to redirect error_logger messages into lager -
%% defaults to true
{mapping, "log.error.redirect", "lager.error_logger_redirect", [
  {default, on},
  {datatype, flag},
  hidden
]}.

%% @doc Maximum number of error_logger messages to handle in a second
{mapping, "log.error.messages_per_second", "lager.error_logger_hwm", [
  {default, 100},
  {datatype, integer},
  hidden
]}.


%% @doc Cookie for distributed node communication.  All nodes in the
%% same cluster should use the same cookie or they will not be able to
%% communicate.
{mapping, "distributed_cookie", "vm_args.-setcookie", [
  {default, "riak"}
]}.

%% @see platform_bin_dir
{mapping, "platform_etc_dir", "emqttd.platform_etc_dir", [
  {datatype, directory},
  {default, "./etc"}
]}.

%% @see platform_bin_dir
{mapping, "platform_log_dir", "emqttd.platform_log_dir", [
  {datatype, directory},
  {default, "./log"}
]}.
